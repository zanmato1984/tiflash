# Overall Work Objectives

- Deliver TiForth as an independent Arrow-native compute library (standalone repo `zanmato1984/tiforth`, consumed by TiFlash via FetchContent / local `libs/tiforth` checkout) with stable host APIs (Engine/Pipeline/Task), Arrow compute integration, and a minimal C ABI surface.
- Integrate TiForth into TiFlash behind `TIFLASH_ENABLE_TIFORTH` with Block<->Arrow bridging, DAG->pipeline translation, and gtests covering a common TiFlash DAG shape.
- Preserve TiFlash/TiDB semantics via a clear logical-type contract (Arrow field metadata) for tricky types (decimals, packed MyTime temporals, collated strings: compare/hash/sort keys).
- Route TiForth allocations through host-provided `arrow::MemoryPool` to support accounting/limits/spill hooks.

# Work in Progress

# To Do

- TiFlash TiForth executor: enable production DAG→TiForth translation for a small supported operator subset (projection/filter/agg/join), keeping native fallback for others; add parity gtests for a representative DAG.
- ArrowComputeAgg string keys: prototype an optional “build stable dictionary then aggregate” mode (buffer+encode) or track/upstream Arrow dictionary unification support; keep default fallback to HashAgg.

# Completed

- TiForth baseline (MS1-13, 2026-01-19): delivered standalone `tiforth` library (Engine/Pipeline/Plan/Task + C ABI skeleton), core operators (projection/filter/hash agg/join/sort) with breaker plan semantics and blocked-state model, Arrow logical-type metadata contract (decimal/MyTime/collations) and custom kernels for TiDB/TiFlash semantics, and TiFlash integration behind `TIFLASH_ENABLE_TIFORTH` (Block<->Arrow bridge + DAG→pipeline translation + parity gtests). Key decision: keep TiForth independent (no TiFlash assumptions) while matching Arrow coding style + rigid checks. Notes: full aggregation core includes TiFlash-shaped method selection + optimized hash tables. 
- MS14 Arrow-compute agg + benchmarks (2026-01-19): implemented TiForth `ArrowComputeAggTransformOp` via Arrow Acero (streaming input; supports compiled expressions via pre-projection; outputs reordered aggs-then-keys) and added TiFlash `bench_dbms` coverage + markdown report + string-key profiling. Found performance profile: numeric keys often faster than Native; string keys slow on raw varbinary but fast with shared-dictionary keys; Arrow cannot unify differing dictionaries across batches. Flamegraph root cause: Arrow grouper hot path on string keys is `GrouperFastImpl` + `SwissTable` with heavy varlen hashing (`HashVarLenImp`) and varbinary compares (`KeyCompare::CompareVarBinaryColumnToRowHelper` + memmove/memcpy); dict keys remove varbinary compare. Files: `libs/tiforth/*` (operator + tests), `dbms/src/Flash/tests/bench_tiforth_arrow_compute_agg.cpp`, `docs/design/2026-01-19-arrow-compute-agg-benchmark-report.md`, `docs/design/2026-01-19-arrow-compute-agg-string-key-profiling.md`, `docs/design/images/2026-01-19-arrowcomputeagg-*-string-uniform_low.svg`.
- TiFlash Arrow-compute agg A/B switch (2026-01-19): added runtime setting `enable_tiforth_arrow_compute_agg`, wired it into the TiFlash-shaped DAG→TiForth pipeline translation test harness to toggle `HashAggTransformOp` vs `ArrowComputeAggTransformOp`, and added a parity gtest for group-by sum (setting flipped on). Validation: `gtests_dbms` + targeted filters pass; branch pushed to `ruoxi/tiforth`. Files: `dbms/src/Interpreters/Settings.h`, `dbms/src/Flash/tests/gtest_tiforth_filter_agg_parity.cpp`, `dbms/src/Flash/tests/gtest_tiforth_pipeline_translate.cpp`, `.codex/progress/daemon.md`.
- TiFlash stream executor wiring (2026-01-19): enabled `enable_tiforth_arrow_compute_agg` for real TiFlash stream execution when `enable_tiforth_executor=1` by injecting a TiForth-backed aggregation stream in `PhysicalAggregation` (uses ArrowComputeAgg for non-string group keys; falls back to TiForth HashAgg on string group keys; safe fallback to native agg for unsupported shapes/collation-sensitive keys). Updated TiForth executor gate to allow non-pass-through DAGs only when opt-in flag is set; added gtests for int64 group-by sum and string-key HashAgg fallback. Files: `dbms/src/Flash/Planner/Plans/PhysicalAggregation.cpp`, `dbms/src/Flash/executeQuery.cpp`, `dbms/src/Flash/TiForth/TiForthAggBlockInputStream.{h,cpp}`, `dbms/src/Flash/tests/gtest_tiforth_query_executor_passthrough.cpp`, `.codex/progress/daemon.md`. Notes: current implementation buffers all input blocks for aggregation; no spill/IO blocked states wired yet.
- String-key perf decision (2026-01-19): keep ArrowComputeAgg for non-string group keys; for string group keys default to TiForth HashAgg (Arrow varlen key path too costly; dictionary keys fast only when dictionary is stable across batches, and Arrow doesn't unify dictionaries). Keep dict-key aggregation as benchmark-only for now; revisit when we can unify dictionaries or add an explicit “build stable dictionary then aggregate” mode. Files: `dbms/src/Interpreters/Settings.h`, `.codex/progress/daemon.md`.
- TiFlash vs Arrow string-key analysis (2026-01-19): documented why TiFlash native string hash agg outperforms Arrow/Acero for short string keys: `StringHashTable` encodes <=24B keys as fixed-width `StringKey8/16/24` (fast hash+equality) and uses saved-hash for long `StringRef`, while Arrow `GrouperFastImpl` always pays varlen hashing + row-table varbinary compares. Files: `docs/design/2026-01-19-arrow-compute-agg-string-key-profiling.md`, `.codex/progress/daemon.md`.
- Objectives review (2026-01-19): confirmed TiForth standalone + FetchContent fallback, TiFlash integration behind `ENABLE_TIFORTH`, and logical-type contract are in place; remaining gaps are query-scoped memory accounting (TiFlash `MemoryTracker` ↔ `arrow::MemoryPool`) and true streaming execution (current TiFlash integration buffers all blocks and does not surface `TaskState` blocked statuses). Updated To Do list accordingly. Files: `.codex/progress/daemon.md`.
- TiFlash↔TiForth memory accounting (2026-01-20): added `TiFlashMemoryPool` (Arrow `MemoryPool` wrapper charging TiFlash `MemoryTracker`) and wired it into TiForth entry points (`executeAsTiForth` pass-through executor + `PhysicalAggregation` TiForth agg injection) so Arrow/TiForth allocations are tracked/limited by query tracker. Added a gtest validating allocate/realloc/free accounting. Files: `dbms/src/Flash/TiForth/TiFlashMemoryPool.{h,cpp}`, `dbms/src/Flash/TiForth/TiForthQueryExecutor.{h,cpp}`, `dbms/src/Flash/TiForth/TiForthAggBlockInputStream.{h,cpp}`, `dbms/src/Flash/executeQuery.cpp`, `dbms/src/Flash/Planner/Plans/PhysicalAggregation.cpp`, `dbms/src/Flash/tests/gtest_tiforth_memory_pool.cpp`, `.codex/progress/daemon.md`.
- TiFlash TiForth executor streaming (2026-01-20): rewrote TiForth execution wrappers to drive a TiForth `Task` incrementally (loop on `Task::Step()` with `PushInput` / `PullOutput`), streaming `BlockInputStream` → Arrow batches (no buffering all blocks) and streaming outputs back to Blocks. Added large-input gtests under a small MemoryTracker limit. Validation: `cmake -S . -B cmake-build-debug`, `ninja -C cmake-build-debug gtests_dbms`, `gtests_dbms --gtest_filter=TiForth*`. Files: `dbms/src/Flash/TiForth/TiForthAggBlockInputStream.{h,cpp}`, `dbms/src/Flash/TiForth/TiForthQueryExecutor.cpp`, `dbms/src/Flash/tests/gtest_tiforth_streaming.cpp`, `.codex/progress/daemon.md`.
- TiFlash TiForth executor blocked states (2026-01-20): wired TiForth `TaskState` blocked statuses into TiFlash wrappers by driving the task via `ExecuteIO` / `Await` / `Notify` until unblocked (avoid calling `Step()` while the task is blocked). Added pilot-operator gtests covering `kIOIn/kIOOut/kWaiting/kWaitForNotify` for both `RunTiForthPipelineOnBlocks` and `TiForthAggBlockInputStream`. Validation: `cmake -S . -B cmake-build-debug`, `ninja -C cmake-build-debug gtests_dbms`, `gtests_dbms --gtest_filter=TiForthBlockedStatesTest.*`. Files: `dbms/src/Flash/TiForth/BlockPipelineRunner.cpp`, `dbms/src/Flash/TiForth/TiForthAggBlockInputStream.cpp`, `dbms/src/Flash/TiForth/TiForthQueryExecutor.cpp`, `dbms/src/Flash/tests/gtest_tiforth_blocked_states.cpp`, `.codex/progress/daemon.md`.
